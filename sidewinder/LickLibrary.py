# -*- coding: utf-8 -*-
"""
Created on Sat Apr 25 11:00:34 2020

@author: Sam
"""
from Sidewinder import synonyms, synonyms_r
synonyms.update(synonyms_r)

from mingus.midi import midi_file_out, midi_file_in
import mingus.core.chords as chords
chord_to_shorthand = {v:k for k,v in chords.chord_shorthand_meaning.items()}

from itertools import combinations


#%%
from tinydb import TinyDB, Query # https://tinydb.readthedocs.io/en/latest/getting-started.html
db = TinyDB(r'C:\Users\Sam\Documents\Sidewinder\local files\jazz-licks-db.json')
db.insert({'name': 'test', 'passage': None, 'tags':'251'})
db_size = len(db.all())

#%% db functions
def find_all_matches(db, entry):
    q = [(Query()[t[0]]==t[1]) for t in [(key,value) for key, value in entry.items()]]
    
    qq = q[0]
    for i, subq in enumerate(q):
        if i>0:
            qq = qq & q[i] # combine the full query with &'s
    
    return [x.doc_id for x in db.search(qq)]

def load_entry(db, entry):
    '''
    Returns the entry as an object 
    '''
    return entry_instantiated_as_lick_object(entry) # placeholder for Class instantiation - defn depends on use reqs e.g. auto-convert between scale degree formats

def add_entry(db, entry):
    '''
    Adds entry with any necessary processing routines e.g. storing reference to pickled/midi/ly passage
    '''
    return new_doc_id


#%%
def analyse_composition(comp):
    print(f'Composition has {len(comp.tracks)} tracks')
    print(f'The first is usually the header (empty) track: {comp.tracks[0]}')
    for i, track in enumerate(comp.tracks):
        print(f'Track {i} is {len(track)} events long:')
        print(track[:2], '...', track[-2:])
    return True

def get_chords_from_track(track):
    results = []
    for i, bar in enumerate(track):
        for j, event in enumerate(bar):
            chord_notes = event[2]
            chord_notes = [note.name for note in chord_notes]

            possible_chord_names = respell_and_determine(chord_notes)
            most_likely_chord_names = [poss[0] for poss in possible_chord_names]
            best_or_none = lambda x: None if x==[] else x[0]
            most_likely_chord = best_or_none(most_likely_chord_names)
            
            # get shorthand as mingus doesn't have a chord-from-fullname function
            if most_likely_chord is not None:
                ch = [most_likely_chord.split(' ')[0]] + [' '.join(most_likely_chord.split(' ')[1:])]
                sh = ch[0] + chord_to_shorthand[f' {ch[1]}']
            else:
                sh = None
            results.append([i, j, most_likely_chord, sh])
    return results

def get_all_chord_respellings(chord):
    respellings = [chord]
    
    candidates = list(set(chord) & set(list(synonyms.keys()) + list(synonyms.values())))
    for i in range(0, len(candidates)):
        combs = combinations(candidates, i+1)
        for comb in combs:
            respelling = chord.copy()
            for to_syn in comb:
                respelling[respelling.index(to_syn)] = synonyms[to_syn]
                respellings.append(respelling)
    return respellings

def respell_and_determine(chord):
    named_chords = [chords.determine(chord)]
    if len(named_chords[0]) == 0:
        named_chords = []
    
    candidates = list(set(chord) & set(list(synonyms.keys()) + list(synonyms.values())))
    for i in range(0, len(candidates)):
        combs = combinations(candidates, i+1)
        for comb in combs:
            respelling = chord.copy()
            for to_syn in comb:
                respelling[respelling.index(to_syn)] = synonyms[to_syn]
                if chords.determine(respelling) != []:
                    named_chords.append(chords.determine(respelling))
    return named_chords

#%% examples
# Load midi generated by Lilypond (Frescobaldi)
y_comp, y_bpm = midi_file_in.MIDI_to_Composition(r'C:\Users\Sam\Documents\Sidewinder\local files\jiminpark\20 Licks in Jazz 251.mid')

# Re-export as midi for validation
midi_file_out.write_Composition(r'C:\Users\Sam\Documents\Sidewinder\local files\jiminpark\maj251_out.mid', 
                                y_comp, repeat=0, verbose=True)
    